<html>
<head>
<title>Javascript Shapefile and DBF Loader</title>
<script type="text/javascript" src="lib/binaryajax.js"></script>
<script type="text/javascript" src="src/binarywrapper.js"></script>
<script type="text/javascript" src="src/shapefile.js"></script>
<script type="text/javascript" src="src/dbf.js"></script>
<!--[if IE]><script src="lib/excanvas.js"></script><![endif]-->
<script type="text/javascript">

function Map(id, layers) {

  var parent = document.getElementById(id);
  if (!parent.style.position) parent.style.position = 'relative';
  
  for (var i = 0; i < layers.length; i++) {
    if (window.console && window.console.log) console.log('creating canvas...');

    var layer = layers[i];

    var canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.left = '0px';
    canvas.style.top = '0px';
    // TODO get these from parent properties or in constructor:
    canvas.style.width = '1024px';
    canvas.style.height = '512px';
    parent.appendChild(canvas);
    if (window.G_vmlCanvasManager) {
      canvas = G_vmlCanvasManager.initElement(canvas); 
    }  
    canvas.width = parseInt(canvas.style.width.match(/\d+/));
    canvas.height = parseInt(canvas.style.height.match(/\d+/));

    layer.canvas = canvas;
    layer.onComplete = onLayerComplete;
    
    layer.load();
  }
  
}

function onLayerComplete(shpFile, dbfFile) {
  var box = { x: -180, y: -90, width: 360, height: 180 };
  if (shpFile.header.shapeType == ShpType.SHAPE_POLYGON || shpFile.header.shapeType == ShpType.SHAPE_POLYLINE) {
    renderPolygons(this.canvas, shpFile.records, dbfFile.records, box, this.style);
  }
  else if (shpFile.header.shapeType == ShpType.SHAPE_POINT) {
    renderPoints(this.canvas, shpFile.records, dbfFile.records, box, this.style);
  }
}

function Layer(url, style) {

  var shpURL = url+'.shp';
  var dbfURL = url+'.dbf';
  this.style = style;

  var theLayer = this;
  
  var loadComplete = function() {
    if (theLayer.dbfFile && theLayer.shpFile && theLayer.onComplete) {
      theLayer.onComplete.apply(theLayer, [ theLayer.shpFile, theLayer.dbfFile ]);
      // TODO: cleanup?
    }
  }
  
  var onShpFail = function() { 
    alert('failed to load ' + theLayer.shpURL);
  };
  var onDbfFail = function() { 
    alert('failed to load ' + theLayer.dbfURL);
  }

  var onShpComplete = function(oHTTP) {
    var binFile = oHTTP.binaryResponse;
    if (window.console && window.console.log) console.log('got data for ' + theLayer.shpURL + ', parsing shapefile');
    theLayer.shpFile = new ShpFile(binFile);
    loadComplete();
  }

  var onDbfComplete = function(oHTTP) {
    var binFile = oHTTP.binaryResponse;
    if (window.console && window.console.log) console.log('got data for ' + theLayer.dbfURL + ', parsing dbf file');
    theLayer.dbfFile = new DbfFile(binFile);
    loadComplete();
  }  

  this.load = function() {
    this.shpURL = shpURL;
    this.dbfURL = dbfURL;
    this.shpLoader = new BinaryAjax(shpURL, onShpComplete, onShpFail);
    this.dbfLoader = new BinaryAjax(dbfURL, onDbfComplete, onDbfFail);
  }
}

function renderPoints(canvas, records, data, box, style) {

  if (window.console && window.console.log) console.log('rendering points');

  var t1 = new Date().getTime();
  if (window.console && window.console.log) console.log('starting rendering...');

  var ctx = canvas.getContext('2d');
  
  var sc = Math.min(canvas.width / box.width, canvas.height / box.height);

  if (style) {
    for (var p in style) {
      ctx[p] = style[p];
    }
  }

  // TODO: style attributes for point type (circle, square) and size/radius

  for (var i = 0; i < records.length; i++) {
    var record = records[i];
    if (record.shapeType == ShpType.SHAPE_POINT) {
      var shp = record.shape;
      if (style.fillStyle) {
        ctx.fillRect(-1.5 + (shp.x - box.x) * sc, -1.5 + canvas.height - (shp.y - box.y) * sc, 3, 3);
      }
      if (style.strokeStyle) {
        ctx.strokeRect(-1.5 + (shp.x - box.x) * sc, -1.5 + canvas.height - (shp.y - box.y) * sc, 3, 3);
      }
    }
  }
  t2 = new Date().getTime();
  if (window.console && window.console.log) console.log('done rendering in ' + (t2 - t1) + ' ms');
}

function renderPolygons(canvas, records, data, box, style) {

  if (window.console && window.console.log) console.log('rendering polygons');

  var t1 = new Date().getTime();
  if (window.console && window.console.log) console.log('starting rendering...');

  var ctx = canvas.getContext('2d');
  
  var sc = Math.min(canvas.width / box.width, canvas.height / box.height);

  if (style) {
    for (var p in style) {
      ctx[p] = style[p];
    }
  }
  for (var i = 0; i < records.length; i++) {
    var record = records[i];
    if (record.shapeType == ShpType.SHAPE_POLYGON || record.shapeType == ShpType.SHAPE_POLYLINE) {
      var shp = record.shape;
      ctx.beginPath();
      for (var j = 0; j < shp.rings.length; j++) {
        var ring = shp.rings[j];
        if (ring.length < 1) continue;
        ctx.moveTo((ring[0].x - box.x) * sc, canvas.height - (ring[0].y - box.y) * sc);
        for (var k = 1; k < ring.length; k++) {
          ctx.lineTo((ring[k].x - box.x) * sc, canvas.height - (ring[k].y - box.y) * sc);
        }
      }
      if (style.fillStyle && record.shapeType == ShpType.SHAPE_POLYGON) {
        ctx.fill();
      }
      if (style.strokeStyle) {
        ctx.stroke();
      }
    }
  }
  t2 = new Date().getTime();
  if (window.console && window.console.log) console.log('done rendering in ' + (t2 - t1) + ' ms');
}

window.onload = function() {

  // currently styling works like this:
  // - if there's a fillStyle then it will be filled 
  // - if there's a strokeStyle then it will be stroked
  // - points are always 3px rectangles
  // - polylines can't be filled

  var map1 = new Map('physical', [
    new Layer("naturalearthdata/physical/110m-ocean", { fillStyle: '#9dc3e0', strokeStyle: '#8db3d0', lineWidth: '5' }),
    new Layer("naturalearthdata/physical/110m-geography-marine-polys", { strokeStyle: '#ffff80', lineWidth: '0.5' }),
    new Layer("naturalearthdata/physical/110m-land", { fillStyle: '#202020' }),
    new Layer("naturalearthdata/physical/110m-geography-regions-polys", { strokeStyle: 'rgba(100,100,100,0.5)', lineWidth: '0.5' }),
    new Layer("naturalearthdata/physical/110m-glaciated-areas", { fillStyle: 'rgb(40,40,70)' }),    
    new Layer("naturalearthdata/physical/110m-coastline", { strokeStyle: '#ffffff', lineWidth: '2.0' }),
    new Layer("naturalearthdata/physical/110m-geography-regions-points", { fillStyle: 'red' }),
    new Layer("naturalearthdata/physical/110m-lakes", { fillStyle: '#9dc3e0', strokeStyle: 'white', lineWidth: '0.5' }),
    new Layer("naturalearthdata/physical/110m-physical-geographic-lines", { strokeStyle: 'white', lineWidth: '0.5' }),
    new Layer("naturalearthdata/physical/110m-rivers-lake-centerlines", { strokeStyle: '#9dc3e0', lineWidth: '0.5' }) 
  ]);
  
  var map2 = new Map('cultural', [
    // country shapes
    new Layer('naturalearthdata/cultural/110m-admin-0-countries', { fillStyle: '#fadfa8', strokeStyle: '#5c3d1f', lineWidth: '0.5' }),
    // mainly USA state shapes
    new Layer('naturalearthdata/cultural/110m-admin-1-states-provinces-poly-shp', { fillStyle: '#fadfa8', strokeStyle: '#5c3d1f', lineWidth: '1' }),
    // mainly USA state boundaries
    new Layer('naturalearthdata/cultural/110m-admin-1-states-provinces-lines-shp', { strokeStyle: '#9b5c3d', lineWidth: '0.5' }),
    // internal country borders:
    new Layer('naturalearthdata/cultural/110m-admin-0-boundary-lines', { strokeStyle: '#9b5c3d', lineWidth: '1' }),
    // mainly the lines around the pacific islands
    new Layer('naturalearthdata/cultural/110m-admin-0-pacific-groupings', { strokeStyle: '#3993c7', lineWidth: '0.5' }),
    // dots for small countries?
    new Layer('naturalearthdata/cultural/110m-admin-0-tiny-countries', { fillStyle: 'rgb(0,0,0)' }),
    // dots for cities
    new Layer('naturalearthdata/cultural/110m-populated-places', { fillStyle: 'rgb(0,0,0)' })
  ]);
  
}

</script>
<style type="text/css">
body {
  background-color: #eee;
  color: #000;
  font: 12px sans-serif;
  margin: 20px;
}
.map {
  width: 1024px;
  height: 512px;
  margin: 0;
  padding: 0;
  border: 0;
}
#cultural {
  background-color: #9dc3e0;
}
#physical {
  background-color: #9dc3e0;
}
canvas {
  margin: 0;
  padding: 0;
}
a img {
  border: 0;
}
</style>
</head>
<body>
<h1>Natural Earth</h1>
<p>This is an experimental javascript shapefile viewer. For no reason in particular it doesn't really work in IE, sorry. Elsewhere, uninformative errors may appear in the dark crevices of your browser.</p>
<p>See <a href="http://github.com/RandomEtc/shapefile-js">http://github.com/RandomEtc/shapefile-js</a> for more details.</p>
<h2>110m Physical Vectors (10 layers)</h2>
<div class="map" id="physical"></div>
<h2>110m Cultural Vectors (7 layers)</h2>
<div class="map" id="cultural"></div>
<p><a href="http://www.naturalearthdata.com/"><img src="naturalearthdata/NEV-Logo-Black_sm.png"></a></p>
</body>
</html>
